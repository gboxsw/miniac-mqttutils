package com.gboxsw.miniac.mqttutils;

import java.io.*;
import java.util.*;

import org.eclipse.paho.client.mqttv3.*;

/**
 * Factory generating basic MQTT instances with respect to given configuration.
 * 
 */
public final class MqttFactory {

	/**
	 * The empty payload (byte array).
	 */
	private static final byte[] EMPTY_PAYLOAD = new byte[0];

	/**
	 * Names of configurable properties.
	 */
	private static final String[] propertyNames = { "ServerURI", "ClientId", "ClientIdPrefix", "UserName", "Password",
			"AutomaticReconnect", "CleanSession", "ConnectionTimeout", "KeepAliveInterval", "MaxInflight", "MessageQoS",
			"MqttVersion" };

	/**
	 * The address of the server to connect to, specified as a URI.
	 */
	private String serverUri = "";

	/**
	 * The client identifier that is unique on the server being connected to.
	 */
	private String clientId = "";

	/**
	 * The prefix for autogenerated client identifiers (in the case when
	 * clientId is an empty string).
	 */
	private String clientIdPrefix = "";

	/**
	 * Username.
	 */
	private String userName = "";

	/**
	 * Password.
	 */
	private String password = "";

	/**
	 * Basic pre-configured connect options.
	 */
	private final MqttConnectOptions basicConnectOptions;

	/**
	 * Default quality-of-service for messages created by this factory.
	 */
	private volatile int messageQoS;

	/**
	 * Indicates whether the configuration of the factory is mutable.
	 */
	private final boolean mutable;

	/**
	 * Synchronization lock.
	 */
	private final Object lock = new Object();

	/**
	 * Constructs a factory.
	 */
	public MqttFactory() {
		mutable = true;
		basicConnectOptions = new MqttConnectOptions();

		MqttMessage msq = new MqttMessage();
		messageQoS = msq.getQos();
	}

	/**
	 * Creates an immutable factory whose configuration is copied from
	 * configuration of a source factory.
	 * 
	 * @param source
	 *            the source factory.
	 */
	public MqttFactory(MqttFactory source) {
		this(source, false);
	}

	public MqttFactory(MqttFactory source, boolean mutable) {
		if (source == null) {
			throw new NullPointerException("Source factory cannot be null.");
		}

		this.mutable = mutable;

		synchronized (source.lock) {
			basicConnectOptions = source.cloneBasicConnectOptions();
			serverUri = source.serverUri;
			clientId = source.clientId;
			clientIdPrefix = source.clientIdPrefix;

			userName = source.userName;
			password = source.password;
			messageQoS = source.messageQoS;
		}
	}

	/**
	 * Creates a new instance of {@link IMqttClient}.
	 * 
	 * @return the instance.
	 */
	public IMqttClient createClient() {
		synchronized (lock) {
			try {
				MqttClient client = new MqttClient(serverUri, generateClientId(), null);
				return client;
			} catch (Exception e) {
				throw new MqttFactoryException("Construction of MQTT client failed.", e);
			}
		}
	}

	/**
	 * Creates a new instance of {@link IMqttAsyncClient}.
	 * 
	 * @return the instance.
	 */
	public IMqttAsyncClient createAsyncClient() {
		synchronized (lock) {
			try {
				MqttAsyncClient client = new MqttAsyncClient(serverUri, generateClientId(), null);
				return client;
			} catch (Exception e) {
				throw new MqttFactoryException("Construction of async MQTT client failed.", e);
			}
		}
	}

	/**
	 * Creates new instance of {@link MqttConnectOptions}.
	 * 
	 * @return the pre-configured instance.
	 */
	public MqttConnectOptions createConnectOptions() {
		synchronized (lock) {
			try {
				MqttConnectOptions result = cloneBasicConnectOptions();

				result.setServerURIs(new String[] { serverUri });
				if (!userName.isEmpty()) {
					result.setUserName(userName);
				}

				if (!userName.isEmpty() && !password.isEmpty()) {
					result.setPassword(password.toCharArray());
				}

				return result;
			} catch (Exception e) {
				throw new MqttFactoryException("Construction of MQTT connect options failed.", e);
			}
		}
	}

	/**
	 * Creates a mqtt message.
	 * 
	 * @param payload
	 *            the payload.
	 * @return the message.
	 */
	public MqttMessage createMessage(byte[] payload) {
		MqttMessage result = new MqttMessage(payload);
		result.setQos(messageQoS);
		return result;
	}

	/**
	 * Creates an empty mqtt message.
	 * 
	 * @return the message.
	 */
	public MqttMessage createMessage() {
		return createMessage(EMPTY_PAYLOAD);
	}

	/**
	 * Creates a new instance of {@link MqttConnectOptions} that is a clone of
	 * the basic connect options.
	 * 
	 * @return the pre-configured instance of {@link MqttConnectOptions}.
	 */
	private MqttConnectOptions cloneBasicConnectOptions() {
		MqttConnectOptions result = new MqttConnectOptions();

		result.setAutomaticReconnect(basicConnectOptions.isAutomaticReconnect());
		result.setCleanSession(basicConnectOptions.isCleanSession());
		result.setConnectionTimeout(basicConnectOptions.getConnectionTimeout());
		result.setKeepAliveInterval(basicConnectOptions.getKeepAliveInterval());
		result.setMaxInflight(basicConnectOptions.getMaxInflight());
		result.setMqttVersion(basicConnectOptions.getMqttVersion());

		return result;
	}

	/**
	 * Checks whether properties of the factory can be modified. If this is not
	 * the case, an exception is thrown.
	 */
	private void checkMutability() {
		if (!mutable) {
			throw new IllegalStateException("The factory is immutable.");
		}
	}

	/**
	 * Returns a client id.
	 * 
	 * @return the client id.
	 */
	private String generateClientId() {
		if (!clientId.isEmpty()) {
			return clientId;
		}

		String result = clientIdPrefix;
		result += MqttClient.generateClientId();

		return result;
	}

	public String getServerUri() {
		synchronized (lock) {
			return serverUri;
		}
	}

	public void setServerUri(String serverUri) {
		synchronized (lock) {
			checkMutability();

			try {
				MqttConnectOptions.validateURI(serverUri);
			} catch (Exception e) {
				throw new MqttFactoryException("Invalid URI of server.", e);
			}

			this.serverUri = serverUri;
		}
	}

	public String getClientIdPrefix() {
		synchronized (lock) {
			return clientIdPrefix;
		}
	}

	public void setClientIdPrefix(String clientIdPrefix) {
		if (clientIdPrefix == null) {
			clientIdPrefix = "";
		}

		synchronized (lock) {
			checkMutability();
			this.clientIdPrefix = clientIdPrefix.trim();
		}
	}

	public String getUserName() {
		synchronized (lock) {
			return userName;
		}
	}

	public void setUserName(String userName) {
		if (userName == null) {
			userName = "";
		}

		synchronized (lock) {
			checkMutability();
			this.userName = userName.trim();
		}
	}

	public String getPassword() {
		synchronized (lock) {
			return password;
		}
	}

	public void setPassword(String password) {
		if (password == null) {
			password = "";
		}

		synchronized (lock) {
			checkMutability();
			this.password = password;
		}
	}

	public int getMessageQoS() {
		return messageQoS;
	}

	public void setMessageQoS(int messageQoS) {
		if ((messageQoS < 0) || (messageQoS > 2)) {
			throw new IllegalArgumentException("The QoS value must be 0, 1, or 2.");
		}

		synchronized (lock) {
			checkMutability();
			this.messageQoS = messageQoS;
		}
	}

	public String getClientId() {
		synchronized (lock) {
			return clientId;
		}
	}

	public void setClientId(String clientId) {
		if (clientId == null) {
			clientId = "";
		}

		synchronized (lock) {
			checkMutability();
			this.clientId = clientId.trim();
		}
	}

	/**
	 * Returns whether the client will automatically attempt to reconnect to the
	 * server if the connection is lost
	 * 
	 * @see MqttConnectOptions#isAutomaticReconnect()
	 * @return the automatic reconnection flag.
	 */
	public boolean isAutomaticReconnect() {
		synchronized (lock) {
			return basicConnectOptions.isAutomaticReconnect();
		}
	}

	/**
	 * Sets whether the client will automatically attempt to reconnect to the
	 * server if the connection is lost.
	 * 
	 * @see MqttConnectOptions#setAutomaticReconnect(boolean)
	 * 
	 * @param automaticReconnect
	 *            If set to True, Automatic Reconnect will be enabled
	 */
	public void setAutomaticReconnect(boolean automaticReconnect) {
		synchronized (lock) {
			checkMutability();
			basicConnectOptions.setAutomaticReconnect(automaticReconnect);
		}
	}

	/**
	 * Returns whether the client and server should remember state for the
	 * client across reconnects.
	 * 
	 * @return the clean session flag.
	 */
	public boolean isCleanSession() {
		synchronized (lock) {
			return basicConnectOptions.isCleanSession();
		}
	}

	/**
	 * Sets whether the client and server should remember state across restarts
	 * and reconnects.
	 * 
	 * @see MqttConnectOptions#setCleanSession(boolean)
	 * 
	 * @param cleanSession
	 *            set to True to enable cleanSession.
	 */
	public void setCleanSession(boolean cleanSession) {
		synchronized (lock) {
			checkMutability();
			basicConnectOptions.setCleanSession(cleanSession);
		}
	}

	/**
	 * Returns the connection timeout value.
	 * 
	 * @see #setConnectionTimeout(int)
	 * @return the connection timeout value.
	 */
	public int getConnectionTimeout() {
		synchronized (lock) {
			return basicConnectOptions.getConnectionTimeout();
		}
	}

	/**
	 * Sets the connection timeout value.
	 * 
	 * @see MqttConnectOptions#setConnectionTimeout(int)
	 * 
	 * @param connectionTimeout
	 *            the timeout value, measured in seconds. It must be &gt;0;
	 */
	public void setConnectionTimeout(int connectionTimeout) {
		synchronized (lock) {
			checkMutability();
			basicConnectOptions.setConnectionTimeout(connectionTimeout);
		}
	}

	/**
	 * Returns the "keep alive" interval.
	 * 
	 * @see #setKeepAliveInterval(int)
	 * @return the keep alive interval.
	 */
	public int getKeepAliveInterval() {
		synchronized (lock) {
			return basicConnectOptions.getKeepAliveInterval();
		}
	}

	/**
	 * Sets the "keep alive" interval.
	 * 
	 * @see MqttConnectOptions#setKeepAliveInterval(int)
	 * 
	 * @param keepAliveInterval
	 *            the interval, measured in seconds, must be &gt;= 0.
	 * @throws IllegalArgumentException
	 *             if the keepAliveInterval was invalid
	 */
	public void setKeepAliveInterval(int keepAliveInterval) {
		synchronized (lock) {
			checkMutability();
			basicConnectOptions.setKeepAliveInterval(keepAliveInterval);
		}
	}

	/**
	 * Returns the "max inflight". The max inflight limits to how many messages
	 * we can send without receiving acknowledgments.
	 * 
	 * @see #setMaxInflight(int)
	 * @return the max inflight
	 */
	public int getMaxInflight() {
		synchronized (lock) {
			return basicConnectOptions.getMaxInflight();
		}
	}

	/**
	 * Sets the "max inflight".
	 * 
	 * @see MqttConnectOptions#setMaxInflight(int)
	 * 
	 * @param maxInflight
	 *            the number of maxInfligt messages
	 */
	public void setMaxInflight(int maxInflight) {
		synchronized (lock) {
			checkMutability();
			basicConnectOptions.setMaxInflight(maxInflight);
		}
	}

	/**
	 * Returns the MQTT version.
	 * 
	 * @see #setMqttVersion(int)
	 * @return the MQTT version.
	 */
	public int getMqttVersion() {
		synchronized (lock) {
			return basicConnectOptions.getMqttVersion();
		}
	}

	/**
	 * Sets the MQTT version.
	 * 
	 * @see MqttConnectOptions#setMqttVersion(int)
	 * @param MqttVersion
	 *            the version of the MQTT protocol.
	 * @throws IllegalArgumentException
	 *             If the MqttVersion supplied is invalid
	 */
	public void setMqttVersion(int mqttVersion) {
		synchronized (lock) {
			checkMutability();
			basicConnectOptions.setMqttVersion(mqttVersion);
		}
	}

	/**
	 * Sets value of a configuration property.
	 * 
	 * @param name
	 *            the name of configuration property.
	 * @param value
	 *            the value of configuration property.
	 */
	public void setProperty(String name, String value) {
		if (value == null) {
			value = "";
		}
		value = value.trim();

		switch (name.toLowerCase()) {
		case "serveruri":
			setServerUri(value);
			break;
		case "clientid":
			setClientId(value);
			break;
		case "clientidprefix":
			setClientIdPrefix(value);
			break;
		case "username":
			setUserName(value);
			break;
		case "password":
			setPassword(value);
			break;
		case "automaticreconnect":
			setAutomaticReconnect(Boolean.valueOf(value));
			break;
		case "cleansession":
			setCleanSession(Boolean.valueOf(value));
			break;
		case "connectiontimeout":
			setConnectionTimeout(Integer.valueOf(value));
			break;
		case "keepaliveinterval":
			setKeepAliveInterval(Integer.valueOf(value));
			break;
		case "maxinflight":
			setMaxInflight(Integer.valueOf(value));
			break;
		case "messageqos":
			setMessageQoS(Integer.valueOf(value));
			break;
		case "mqttversion":
			switch (value) {
			case "3.1":
				setMqttVersion(MqttConnectOptions.MQTT_VERSION_3_1);
				break;
			case "3.1.1":
				setMqttVersion(MqttConnectOptions.MQTT_VERSION_3_1_1);
				break;
			default:
				setMqttVersion(MqttConnectOptions.MQTT_VERSION_DEFAULT);
			}
		default:
			break;
		}
	}

	/**
	 * Returns value of a configuration property.
	 * 
	 * @param name
	 *            the name of configuration property.
	 * @return the value of configuration property encoded as a string.
	 */
	public String getProperty(String name) {
		switch (name.toLowerCase()) {
		case "serveruri":
			return getServerUri();
		case "clientid":
			return getClientId();
		case "clientidprefix":
			return getClientIdPrefix();
		case "username":
			return getUserName();
		case "password":
			return getPassword();
		case "automaticreconnect":
			return Boolean.toString(isAutomaticReconnect());
		case "cleansession":
			return Boolean.toString(isCleanSession());
		case "connectiontimeout":
			return Integer.toString(getConnectionTimeout());
		case "keepaliveinterval":
			return Integer.toString(getKeepAliveInterval());
		case "maxinflight":
			return Integer.toString(getMaxInflight());
		case "messageqos":
			return Integer.toString(getMessageQoS());
		case "mqttversion":
			switch (getMqttVersion()) {
			case MqttConnectOptions.MQTT_VERSION_3_1:
				return "3.1";
			case MqttConnectOptions.MQTT_VERSION_3_1_1:
				return "3.1.1";
			default:
				return "default";
			}

		default:
			return null;
		}
	}

	/**
	 * Returns map with current values of all properties.
	 * 
	 * @return the map with property values.
	 */
	public Map<String, String> getProperties() {
		synchronized (lock) {
			Map<String, String> result = new HashMap<>();
			for (String propertyName : propertyNames) {
				String value = getProperty(propertyName);
				if ((value != null) && (!value.trim().isEmpty())) {
					result.put(propertyName, value);
				}
			}
			return result;
		}
	}

	/**
	 * Sets properties of the factory according to map values.
	 * 
	 * @param properties
	 *            the map with property values.
	 */
	public void setProperties(Map<String, String> properties) {
		synchronized (lock) {
			checkMutability();
			for (Map.Entry<String, String> propertyEntry : properties.entrySet()) {
				setProperty(propertyEntry.getKey(), propertyEntry.getValue());
			}
		}
	}

	/**
	 * Sets properties of the factory according to a configuration file.
	 * 
	 * @param configurationFile
	 *            the text file with configuration.
	 */
	public void setPropertiesFromFile(File configurationFile) {
		setProperties(readConfiguration(configurationFile));
	}

	/**
	 * Reads configuration from file.
	 * 
	 * @param configurationFile
	 *            the configuration file.
	 * @return the map with configuration values.
	 * @throws FileNotFoundException
	 */
	private static Map<String, String> readConfiguration(File configurationFile) {
		Map<String, String> result = new HashMap<>();
		try (Scanner lineScanner = new Scanner(configurationFile)) {
			while (lineScanner.hasNextLine()) {
				String line = lineScanner.nextLine().trim();
				if (line.isEmpty() || line.startsWith("#")) {
					continue;
				}

				String key = null;
				String value = "";
				int separatorIndex = line.indexOf('=');
				if (separatorIndex > 0) {
					key = line.substring(0, separatorIndex).trim();
					value = line.substring(separatorIndex + 1).trim();
				}

				if ((key == null) || key.isEmpty()) {
					throw new MqttFactoryException("No key found in line \"" + line + "\" of file \""
							+ configurationFile.getAbsolutePath() + "\".");
				}

				result.put(key, value);
			}
		} catch (FileNotFoundException e) {
			throw new MqttFactoryException(
					"Configuration file \"" + configurationFile.getAbsolutePath() + "\" was not found.", e);
		} catch (Exception e) {
			throw new MqttFactoryException(
					"Invalid format of configuration file \"" + configurationFile.getAbsolutePath() + "\".", e);
		}

		return result;
	}
}
